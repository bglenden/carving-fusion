/**
 * Core plugin management logic implementation
 */

#include "PluginManager.h"

#include <algorithm>
#include <fstream>
#include <set>
#include <sstream>

#include "../../include/geometry/Point2D.h"
#include "../../include/geometry/Point3D.h"
#include "../../include/geometry/VCarveCalculator.h"
#include "../../include/parsers/DesignParser.h"
#include "../../include/utils/TempFileManager.h"
#include "../utils/UnitConversion.h"
#include "../version.h"

namespace ChipCarving {
namespace Core {

PluginManager::PluginManager(std::unique_ptr<Adapters::IFusionFactory> factory)
    : factory_(std::move(factory)), initialized_(false) {}

bool PluginManager::initialize() {
    if (initialized_) {
        return true;
    }

    try {
        // Create dependencies through factory
        logger_ = factory_->createLogger();
        ui_ = factory_->createUserInterface();

        // Debug: Log workspace creation
        logger_->logInfo("About to call factory_->createWorkspace()");
        workspace_ = factory_->createWorkspace();
        logger_->logInfo("factory_->createWorkspace() completed");

        if (workspace_) {
            logger_->logInfo("Workspace created successfully");
        } else {
            logger_->logError("Workspace is null after creation!");
        }

        if (!logger_ || !ui_ || !workspace_) {
            return false;
        }

        // Initialize MedialAxisProcessor with default parameters
        medialProcessor_ = std::make_unique<Geometry::MedialAxisProcessor>(0.25, 0.8);
        medialProcessor_->setVerbose(true);  // Enable verbose logging to debug crash

        // Clear debug logs on startup for fresh debugging
        std::string debugLogPath = chip_carving::TempFileManager::getLogFilePath("medial_axis_debug.log");
        std::string immediateLogPath = chip_carving::TempFileManager::getLogFilePath("medial_immediate.log");
        std::ofstream clearLog1(debugLogPath, std::ios::out);
        clearLog1.close();
        std::ofstream clearLog2(immediateLogPath, std::ios::out);
        clearLog2.close();

        logStartup();
        initialized_ = true;

        logger_->logInfo("Plugin initialization completed successfully");
        return true;

    } catch (const std::exception& e) {
        if (logger_) {
            logger_->logError("Exception during initialization: " + std::string(e.what()));
        }
        return false;
    } catch (...) {
        if (logger_) {
            logger_->logError("Unknown exception during initialization");
        }
        return false;
    }
}

void PluginManager::shutdown() {
    if (!initialized_) {
        return;
    }

    try {
        logShutdown();

        // Clean up resources
        workspace_.reset();
        ui_.reset();
        logger_.reset();
        factory_.reset();

        initialized_ = false;

    } catch (const std::exception& e) {
        if (logger_) {
            logger_->logError("Exception during shutdown: " + std::string(e.what()));
        }
    } catch (...) {
        if (logger_) {
            logger_->logError("Unknown exception during shutdown");
        }
    }
}

bool PluginManager::executeImportDesign() {
    if (!initialized_) {
        return false;
    }

    try {
        logger_->logInfo("Import Design command executed");

        // Get file selection from user
        std::string filePath = ui_->showFileDialog("Select Design File", "JSON Files (*.json)");

        if (filePath.empty()) {
            logger_->logInfo("Import Design cancelled by user");
            return true;  // User cancelled, not an error
        }

        // Read and parse the design file
        logger_->logInfo("Parsing design file: " + filePath);
        auto design = Parsers::DesignParser::parseFromFile(filePath, logger_.get());

        logger_->logInfo("Successfully parsed design with " + std::to_string(design.shapes.size()) +
                         " shapes");

        // Clear previous imports
        importedShapes_.clear();

        // Store shapes for medial axis processing
        int shapeCount = 0;
        for (auto& shape : design.shapes) {
            try {
                // Move shape to our storage (transfer ownership)
                importedShapes_.push_back(std::move(shape));
                shapeCount++;
            } catch (const std::exception& e) {
                logger_->logError("Failed to store shape " + std::to_string(shapeCount + 1) + ": " +
                                  std::string(e.what()));
                // Continue with other shapes
            }
        }

        // Store the file path for reference
        lastImportedFile_ = filePath;

        // Create sketch from stored shapes for visualization
        auto sketch = workspace_->createSketch("Imported Design");
        if (!sketch) {
            throw std::runtime_error("Failed to create sketch in workspace");
        }

        // Add each stored shape to the sketch
        for (size_t i = 0; i < importedShapes_.size(); ++i) {
            const auto& shape = importedShapes_[i];
            try {
                // Log shape bounds for debugging
                Geometry::Point2D minPt, maxPt;
                shape->getBounds(minPt, maxPt);
                logger_->logInfo("Importing shape " + std::to_string(i) + 
                               " bounds: (" + std::to_string(minPt.x) + ", " + std::to_string(minPt.y) + 
                               ") to (" + std::to_string(maxPt.x) + ", " + std::to_string(maxPt.y) + ") cm");
                
                // Log shape centroid
                Geometry::Point2D centroid = shape->getCentroid();
                logger_->logInfo("Shape " + std::to_string(i) + " centroid: (" + 
                               std::to_string(centroid.x) + ", " + std::to_string(centroid.y) + ") cm");
                
                sketch->addShape(shape.get(), logger_.get());
            } catch (const std::exception& e) {
                logger_->logError("Failed to add shape to sketch: " + std::string(e.what()));
                // Continue with other shapes
            }
        }

        // Log completion (no popup)
        logger_->logInfo("Import Design completed: " + std::to_string(shapeCount) +
                         " shapes imported and stored from " + filePath);

        return true;

    } catch (const std::exception& e) {
        std::string errorMsg = "Failed to import design: " + std::string(e.what());
        logger_->logError(errorMsg);
        ui_->showMessageBox("Import Design - Error", errorMsg);
        return false;
    } catch (...) {
        std::string errorMsg = "Unknown error during import";
        logger_->logError(errorMsg);
        ui_->showMessageBox("Import Design - Error", errorMsg);
        return false;
    }
}

bool PluginManager::executeImportDesign(const std::string& filePath, const std::string& planeEntityId) {
    if (!initialized_) {
        return false;
    }

    try {
        logger_->logInfo("Import Design command executed with plane selection");

        if (filePath.empty()) {
            logger_->logError("No file path provided");
            return false;
        }

        // Read and parse the design file
        logger_->logInfo("Parsing design file: " + filePath);
        auto design = Parsers::DesignParser::parseFromFile(filePath, logger_.get());

        logger_->logInfo("Successfully parsed design with " + std::to_string(design.shapes.size()) +
                         " shapes");

        // Clear previous imports
        importedShapes_.clear();

        // Store shapes for medial axis processing
        int shapeCount = 0;
        for (auto& shape : design.shapes) {
            try {
                // Move shape to our storage (transfer ownership)
                importedShapes_.push_back(std::move(shape));
                shapeCount++;
            } catch (const std::exception& e) {
                logger_->logError("Failed to store shape " + std::to_string(shapeCount + 1) + ": " +
                                  std::string(e.what()));
                // Continue with other shapes
            }
        }

        // Store the file path and plane entity ID for reference
        lastImportedFile_ = filePath;
        lastImportedPlaneEntityId_ = planeEntityId;
        
        // Debug logging
        std::string debugLogPath = chip_carving::TempFileManager::getLogFilePath("fusion_cpp_debug.log");
        std::ofstream debugLog(debugLogPath, std::ios::app);
        debugLog << "[INFO] Stored plane entity ID during import: '" << planeEntityId << "' (length: " << planeEntityId.length() << ")" << std::endl;

        // Create sketch on specified plane or XY plane
        std::unique_ptr<Adapters::ISketch> sketch;
        if (!planeEntityId.empty()) {
            logger_->logInfo("Creating sketch on specified plane/surface: " + planeEntityId);
            sketch = workspace_->createSketchOnPlane("Imported Design", planeEntityId);
        } else {
            logger_->logInfo("Creating sketch on default XY plane");
            sketch = workspace_->createSketch("Imported Design");
        }
        
        if (!sketch) {
            throw std::runtime_error("Failed to create sketch in workspace");
        }

        // Add each stored shape to the sketch
        for (size_t i = 0; i < importedShapes_.size(); ++i) {
            const auto& shape = importedShapes_[i];
            try {
                // Log shape bounds for debugging
                Geometry::Point2D minPt, maxPt;
                shape->getBounds(minPt, maxPt);
                logger_->logInfo("Importing shape " + std::to_string(i) + 
                               " bounds: (" + std::to_string(minPt.x) + ", " + std::to_string(minPt.y) + 
                               ") to (" + std::to_string(maxPt.x) + ", " + std::to_string(maxPt.y) + ") cm");
                
                // Log shape centroid
                Geometry::Point2D centroid = shape->getCentroid();
                logger_->logInfo("Shape " + std::to_string(i) + " centroid: (" + 
                               std::to_string(centroid.x) + ", " + std::to_string(centroid.y) + ") cm");
                
                sketch->addShape(shape.get(), logger_.get());
            } catch (const std::exception& e) {
                logger_->logError("Failed to add shape to sketch: " + std::string(e.what()));
                // Continue with other shapes
            }
        }

        // Log completion (no popup)
        logger_->logInfo("Import Design completed: " + std::to_string(shapeCount) +
                         " shapes imported and stored from " + filePath);

        return true;

    } catch (const std::exception& e) {
        std::string errorMsg = "Failed to import design: " + std::string(e.what());
        logger_->logError(errorMsg);
        ui_->showMessageBox("Import Design - Error", errorMsg);
        return false;
    } catch (...) {
        std::string errorMsg = "Unknown error during design import";
        logger_->logError(errorMsg);
        ui_->showMessageBox("Import Design - Error", errorMsg);
        return false;
    }
}

bool PluginManager::executeGeneratePaths() {
    if (!initialized_) {
        logger_->logError(
            "CRITICAL: executeGeneratePaths() called but PluginManager not initialized!");
        return false;
    }

    try {
        logger_->logError("========================================");
        logger_->logError("CRITICAL BUG: OLD executeGeneratePaths() method called!");
        logger_->logError("This should NEVER happen with Enhanced UI Phase 5.2");
        logger_->logError("The new system should call executeMedialAxisGeneration()");
        logger_->logError("========================================");

        // Check if we have imported shapes
        if (importedShapes_.empty()) {
            std::string message = "OLD METHOD CALLED - No Design Imported\\n\\n";
            message += "This error means the OLD executeGeneratePaths() method\\n";
            message += "is being called instead of the NEW executeMedialAxisGeneration()\\n";
            message += "method. This should NOT happen if using the Enhanced UI.\\n\\n";
            message += "Please check which command you're clicking.";

            logger_->logError("Showing OLD METHOD error dialog to user");
            ui_->showMessageBox("OLD METHOD - Generate Paths", message);
            logger_->logError("OLD Generate Paths method completed - no imported shapes");
            return true;  // Not an error, just nothing to process
        }

        logger_->logInfo("Processing " + std::to_string(importedShapes_.size()) +
                         " shapes for medial axis computation");

        // Create new sketch for medial axis visualization
        auto medialSketch = workspace_->createSketch("Medial Axis Paths");
        if (!medialSketch) {
            throw std::runtime_error("Failed to create medial axis sketch");
        }

        std::vector<Geometry::MedialAxisResults> allResults;
        int successCount = 0;
        int totalPoints = 0;
        double totalLength = 0.0;

        // Process each shape individually
        for (size_t i = 0; i < importedShapes_.size(); ++i) {
            const auto& shape = importedShapes_[i];

            try {
                logger_->logInfo("Computing medial axis for shape " + std::to_string(i + 1));

                // NOTE: Shape-based medial axis computation is deprecated!
                // This old method should not be used - use executeMedialAxisGeneration() instead
                logger_->logError("DEPRECATED: Using old shape-based medial axis computation");
                logger_->logError("This method does not support Fusion profile extraction");

                Geometry::MedialAxisResults results;
                results.success = false;
                results.errorMessage =
                    "Shape-based computation deprecated. Use Enhanced UI command instead.";

                if (results.success) {
                    allResults.push_back(results);
                    successCount++;
                    totalPoints += results.totalPoints;
                    totalLength += results.totalLength;

                    logger_->logInfo("Shape " + std::to_string(i + 1) + " processed: " +
                                     std::to_string(results.numChains) + " chains, " +
                                     std::to_string(results.totalPoints) + " points, " +
                                     std::to_string(results.totalLength) + "mm length");

                    // TODO: Add medial axis visualization to sketch
                    // This will be implemented in the next phase (construction geometry
                    // visualization)

                } else {
                    logger_->logError("Failed to compute medial axis for shape " +
                                      std::to_string(i + 1) + ": " + results.errorMessage);
                }

            } catch (const std::exception& e) {
                logger_->logError("Exception processing shape " + std::to_string(i + 1) + ": " +
                                  std::string(e.what()));
            }
        }

        // Show results summary
        std::string message = "Medial Axis Computation Results\\n\\n";
        message += "✓ C++ MedialAxisProcessor working\\n";
        message += "✓ OpenVoronoi integration complete\\n\\n";
        message += "Processed: " + std::to_string(successCount) + "/" +
                   std::to_string(importedShapes_.size()) + " shapes\\n";
        message += "Total points: " + std::to_string(totalPoints) + "\\n";
        message += "Total length: " + std::to_string(static_cast<int>(totalLength)) + "mm\\n\\n";

        if (successCount > 0) {
            message += "Medial axis paths computed successfully.\\n";
            message += "Next phase: Construction geometry visualization";
        } else {
            message += "No shapes processed successfully.\\n";
            message += "Check the log for error details.";
        }

        ui_->showMessageBox("Generate Paths - Results", message);
        logger_->logInfo("Generate Paths completed: " + std::to_string(successCount) +
                         " shapes processed successfully");

        return true;

    } catch (const std::exception& e) {
        logger_->logError("Exception in Generate Paths: " + std::string(e.what()));
        return false;
    } catch (...) {
        logger_->logError("Unknown exception in Generate Paths");
        return false;
    }
}


std::string PluginManager::getVersion() const {
    return ADDIN_VERSION_STRING;
}

std::string PluginManager::getName() const {
    return std::string(ADDIN_NAME) + " (Refactored)";
}

void PluginManager::logStartup() {
    if (logger_) {
        logger_->logInfo("=== " + getName() + " v" + getVersion() + " Starting ===");
        logger_->logInfo("Built on " + std::string(__DATE__) + " at " + std::string(__TIME__));
        logger_->logInfo("Testable architecture initialized");
        logger_->logInfo("Dependency injection active");
    }
}

void PluginManager::logShutdown() {
    if (logger_) {
        logger_->logInfo("=== " + getName() + " Stopping ===");
        logger_->logInfo("Cleaning up dependency injection");
        logger_->logInfo("=== " + getName() + " Shutdown Complete ===");
    }
}

void PluginManager::setMedialAxisParameters(double polygonTolerance, double medialThreshold) {
    if (medialProcessor_) {
        medialProcessor_->setPolygonTolerance(polygonTolerance);
        medialProcessor_->setMedialThreshold(medialThreshold);

        if (logger_) {
            logger_->logInfo(
                "Updated medial axis parameters: tolerance=" + std::to_string(polygonTolerance) +
                ", threshold=" + std::to_string(medialThreshold));
        }
    }
}

bool PluginManager::executeMedialAxisGeneration(const Adapters::SketchSelection& selection,
                                                const Adapters::MedialAxisParameters& params) {
    logger_->logInfo("========================================");
    logger_->logInfo("NEW METHOD: executeMedialAxisGeneration() called!");
    logger_->logInfo("Enhanced UI Phase 5.2 - Profile geometry extraction");
    logger_->logInfo("========================================");

    // Clear debug logs for fresh debugging session
    std::string debugLogPath = chip_carving::TempFileManager::getLogFilePath("medial_axis_debug.log");
    std::string immediateLogPath = chip_carving::TempFileManager::getLogFilePath("medial_immediate.log");
    std::ofstream clearLog1(debugLogPath, std::ios::out);
    clearLog1.close();
    std::ofstream clearLog2(immediateLogPath, std::ios::out);
    clearLog2.close();

    if (!initialized_) {
        logger_->logError(
            "CRITICAL: executeMedialAxisGeneration() called but PluginManager not initialized!");
        return false;
    }

    try {
        logger_->logInfo("Starting medial axis generation for " +
                         std::to_string(selection.closedPathCount) + " profiles");
        logger_->logInfo("Selection valid: " + std::string(selection.isValid ? "true" : "false"));
        logger_->logInfo("Selection error message: " + selection.errorMessage);
        logger_->logInfo("Number of selected entity IDs: " +
                         std::to_string(selection.selectedEntityIds.size()));

        // Validate selection
        if (!selection.isValid || selection.closedPathCount == 0) {
            std::string errorMsg = "Invalid profile selection: " + selection.errorMessage;
            logger_->logError("Selection validation failed: " + errorMsg);
            logger_->logError("Showing Medial Axis Generation error dialog");
            ui_->showMessageBox("Medial Axis Generation - Error", errorMsg);
            logger_->logError(
                "executeMedialAxisGeneration() returning false due to invalid selection");
            return false;
        }

        // Update medial processor parameters
        medialProcessor_->setPolygonTolerance(params.polygonTolerance);
        // Note: medialThreshold is not user-configurable via UI, uses processor default

        // Try to extract plane information from selected profiles (needed for both visualization and V-carve)
        std::string sourcePlaneId;
        if (!selection.selectedEntityIds.empty()) {
            // Use workspace to extract plane info from first selected profile
            sourcePlaneId = workspace_->extractPlaneEntityIdFromProfile(selection.selectedEntityIds[0]);
        }

        // Only create visualization sketch if generateVisualization is enabled
        std::unique_ptr<Adapters::ISketch> constructionSketch;
        std::string sketchName = "Medial Axis - " + params.toolName;  // Define here for result message
        
        if (params.generateVisualization) {
            // Create or find existing sketch for construction geometry visualization
            // Always create a new sketch on the correct plane (don't reuse old sketches)
            // Delete any existing sketch first to avoid conflicts
            auto existingSketch = workspace_->findSketch(sketchName);
            if (existingSketch) {
                logger_->logInfo("Clearing existing sketch: " + sketchName);
                existingSketch->clearConstructionGeometry();
            }
            
            // Use source plane, stored plane, or default to XY
            if (!sourcePlaneId.empty()) {
                logger_->logInfo("Creating construction sketch on source plane: " + sourcePlaneId);
                
                // Debug logging
                std::string debugLogPath = chip_carving::TempFileManager::getLogFilePath("fusion_cpp_debug.log");
                std::ofstream debugLog(debugLogPath, std::ios::app);
                debugLog << "[INFO] Using source plane entity ID for construction sketch: '" << sourcePlaneId << "' (length: " << sourcePlaneId.length() << ")" << std::endl;
                
                constructionSketch = workspace_->createSketchOnPlane(sketchName, sourcePlaneId);
            } else if (!lastImportedPlaneEntityId_.empty()) {
                logger_->logInfo("Creating construction sketch on stored import plane: " + lastImportedPlaneEntityId_);
                
                // Additional debug logging
                std::string debugLogPath = chip_carving::TempFileManager::getLogFilePath("fusion_cpp_debug.log");
                std::ofstream debugLog(debugLogPath, std::ios::app);
                debugLog << "[INFO] Using stored plane entity ID for construction sketch: '" << lastImportedPlaneEntityId_ << "' (length: " << lastImportedPlaneEntityId_.length() << ")" << std::endl;
                
                constructionSketch = workspace_->createSketchOnPlane(sketchName, lastImportedPlaneEntityId_);
            } else {
                logger_->logInfo("Creating construction sketch on default XY plane");
                constructionSketch = workspace_->createSketch(sketchName);
            }
            
            if (!constructionSketch) {
                std::string errorMsg = "Failed to create construction geometry sketch";
                logger_->logError(errorMsg);
                ui_->showMessageBox("Medial Axis Generation - Error", errorMsg);
                return false;
            }
            logger_->logInfo("Created new sketch: " + sketchName);
        } else {
            logger_->logInfo("Visualization disabled - skipping medial axis sketch creation");
        }

        // Enhanced UI Phase 5.2: Extract geometry from Fusion profiles
        logger_->logInfo("About to call extractProfileGeometry()...");
        std::vector<std::vector<Geometry::Point2D>> profilePolygons;
        std::vector<Adapters::IWorkspace::TransformParams> profileTransforms;
        bool extractionSuccess =
            extractProfileGeometry(selection, profilePolygons, profileTransforms);
        logger_->logInfo("extractProfileGeometry() returned: " +
                         std::string(extractionSuccess ? "true" : "false"));
        logger_->logInfo("Number of extracted polygons: " + std::to_string(profilePolygons.size()));

        if (!extractionSuccess || profilePolygons.empty()) {
            std::string errorMsg = "Failed to extract geometry from selected profiles.\nPlease "
                                   "ensure valid closed sketch profiles are selected.";
            logger_->logError("Profile extraction failed: " + errorMsg);
            logger_->logError("Showing Medial Axis Generation - Extraction Error dialog");
            ui_->showMessageBox("Medial Axis Generation - Extraction Error", errorMsg);
            logger_->logError(
                "executeMedialAxisGeneration() returning false due to extraction failure");
            return false;
        }

        logger_->logInfo("Successfully extracted " + std::to_string(profilePolygons.size()) +
                         " profile geometries");

        std::vector<Geometry::MedialAxisResults> allResults;
        int successCount = 0;
        int totalPoints = 0;
        double totalLength = 0.0;

        // Process each extracted profile polygon
        for (size_t i = 0; i < profilePolygons.size(); ++i) {
            const auto& polygon = profilePolygons[i];
            logger_->logInfo("Processing profile " + std::to_string(i + 1) + " with " +
                             std::to_string(polygon.size()) + " vertices");

            try {
                // Log polygon details before processing
                logger_->logInfo("Polygon vertices for profile " + std::to_string(i + 1) + ":");
                try {
                    for (size_t j = 0; j < polygon.size(); ++j) {
                        logger_->logInfo("  Vertex " + std::to_string(j) + ": (" +
                                         std::to_string(polygon[j].x) + ", " +
                                         std::to_string(polygon[j].y) + ")");
                    }
                } catch (const std::exception& e) {
                    logger_->logError("Exception logging vertices: " + std::string(e.what()));
                }

                logger_->logInfo("About to call medialProcessor_->computeMedialAxis()...");
                logger_->logInfo("medialProcessor_ pointer: " +
                                 std::to_string(medialProcessor_ ? 1 : 0));
                
                // Log polygon bounds before medial axis computation
                if (!polygon.empty()) {
                    double minX = polygon[0].x, maxX = polygon[0].x;
                    double minY = polygon[0].y, maxY = polygon[0].y;
                    for (const auto& pt : polygon) {
                        minX = std::min(minX, pt.x);
                        maxX = std::max(maxX, pt.x);
                        minY = std::min(minY, pt.y);
                        maxY = std::max(maxY, pt.y);
                    }
                    logger_->logInfo("Polygon " + std::to_string(i) + " bounds before medial axis: (" + 
                                   std::to_string(minX) + ", " + std::to_string(minY) + ") to (" + 
                                   std::to_string(maxX) + ", " + std::to_string(maxY) + ") cm");
                    logger_->logInfo("Polygon center: (" + std::to_string((minX + maxX) / 2.0) + ", " + 
                                   std::to_string((minY + maxY) / 2.0) + ") cm");
                }

                // Compute medial axis from polygon vertices using direct Point2D vector method
                auto results = medialProcessor_->computeMedialAxis(polygon);

                logger_->logInfo("medialProcessor_->computeMedialAxis() returned successfully");
                logger_->logInfo("Results success: " +
                                 std::string(results.success ? "true" : "false"));

                if (results.success) {
                    // Log medial axis results bounds
                    if (!results.chains.empty() && !results.chains[0].empty()) {
                        logger_->logInfo("Medial axis result for polygon " + std::to_string(i) + ":");
                        logger_->logInfo("  Chains: " + std::to_string(results.chains.size()) + 
                                       ", Total points: " + std::to_string(results.totalPoints));
                        
                        // Find bounds of medial axis result
                        double minX = results.chains[0][0].x / 10.0;  // Convert mm to cm
                        double maxX = minX, minY = results.chains[0][0].y / 10.0, maxY = minY;
                        for (const auto& chain : results.chains) {
                            for (const auto& pt : chain) {
                                double x_cm = pt.x / 10.0;
                                double y_cm = pt.y / 10.0;
                                minX = std::min(minX, x_cm);
                                maxX = std::max(maxX, x_cm);
                                minY = std::min(minY, y_cm);
                                maxY = std::max(maxY, y_cm);
                            }
                        }
                        logger_->logInfo("  Medial axis bounds: (" + std::to_string(minX) + ", " + 
                                       std::to_string(minY) + ") to (" + std::to_string(maxX) + ", " + 
                                       std::to_string(maxY) + ") cm");
                        logger_->logInfo("  Medial axis center: (" + std::to_string((minX + maxX) / 2.0) + ", " + 
                                       std::to_string((minY + maxY) / 2.0) + ") cm");
                    }
                    
                    allResults.push_back(results);
                    successCount++;
                    totalPoints += results.totalPoints;
                    totalLength += results.totalLength;

                    // Enhanced UI Phase 5.3: Add construction geometry visualization
                    // Only add visualization if enabled
                    if (params.generateVisualization) {
                        // Use the corresponding transform for this profile
                        if (i < profileTransforms.size()) {
                            addConstructionGeometryVisualization(constructionSketch.get(), results,
                                                                 params, profileTransforms[i], polygon);
                        } else {
                            logger_->logError("Transform index out of bounds for profile " +
                                              std::to_string(i));
                        }
                    }

                    logger_->logInfo("Profile " + std::to_string(i + 1) +
                                     " processed: " + formatMedialAxisResults(results));
                } else {
                    logger_->logError("Failed to process profile " + std::to_string(i + 1) + ": " +
                                      results.errorMessage);
                }

            } catch (const std::exception& e) {
                logger_->logError("Exception processing profile " + std::to_string(i + 1) + ": " +
                                  std::string(e.what()));
            }
        }

        // Finalize construction geometry sketch if visualization is enabled
        if (params.generateVisualization && constructionSketch) {
            constructionSketch->finishSketch();
        }

        // Generate V-carve toolpaths if enabled
        if (params.generateVCarveToolpaths && successCount > 0) {
            logger_->logInfo("Generating V-carve toolpaths from medial axis results...");
            
            // Always create a new V-carve sketch on the correct plane
            std::string vcarveSketchName = "V-Carve Toolpaths - " + params.toolName;
            auto existingVcarveSketch = workspace_->findSketch(vcarveSketchName);
            if (existingVcarveSketch) {
                logger_->logInfo("Clearing existing V-carve sketch: " + vcarveSketchName);
                existingVcarveSketch->clearConstructionGeometry();
            }
            
            // Create V-carve sketch on same plane as source design
            std::unique_ptr<Adapters::ISketch> vcarveSketch;
            
            // Use same plane detection logic as construction sketch
            if (!sourcePlaneId.empty()) {
                logger_->logInfo("Creating V-carve sketch on source plane: " + sourcePlaneId);
                vcarveSketch = workspace_->createSketchOnPlane(vcarveSketchName, sourcePlaneId);
            } else if (!lastImportedPlaneEntityId_.empty()) {
                logger_->logInfo("Creating V-carve sketch on stored import plane: " + lastImportedPlaneEntityId_);
                vcarveSketch = workspace_->createSketchOnPlane(vcarveSketchName, lastImportedPlaneEntityId_);
            } else {
                logger_->logInfo("Creating V-carve sketch on default XY plane");
                vcarveSketch = workspace_->createSketch(vcarveSketchName);
            }
            
            if (!vcarveSketch) {
                logger_->logError("Failed to create V-carve toolpath sketch");
            } else {
                logger_->logInfo("Created new V-carve sketch: " + vcarveSketchName);
            }
            
            if (vcarveSketch) {
                // Generate V-carve toolpaths directly from medial axis results (in memory)
                bool vcarveSuccess = generateVCarveToolpaths(allResults, params, vcarveSketch.get(), profileTransforms);
                if (vcarveSuccess) {
                    vcarveSketch->finishSketch();
                    logger_->logInfo("V-carve toolpaths generated successfully in sketch: " + vcarveSketchName);
                } else {
                    logger_->logError("Failed to generate V-carve toolpaths");
                }
            }
        }

        // Show results to user
        std::string resultMsg = "Medial Axis Generation Complete\\n\\n";
        resultMsg += "Processed: " + std::to_string(successCount) + " of " +
                     std::to_string(selection.closedPathCount) + " profiles\\n";
        resultMsg += "Total Points: " + std::to_string(totalPoints) + "\\n";
        resultMsg += "Total Length: " + std::to_string(static_cast<int>(totalLength)) + " mm\\n\\n";
        if (params.generateVisualization) {
            resultMsg += "Construction geometry created in sketch: " + sketchName;
        } else {
            resultMsg += "Visualization disabled - no construction geometry created";
        }
        
        if (params.generateVCarveToolpaths) {
            resultMsg += "\\nV-carve toolpaths: " + ("V-Carve Toolpaths - " + params.toolName);
        }

        // Success popup removed - only log the results
        logger_->logInfo("Medial axis generation completed successfully");
        logger_->logInfo(resultMsg);
        return true;

    } catch (const std::exception& e) {
        std::string errorMsg = "Failed to generate medial axis: " + std::string(e.what());
        logger_->logError(errorMsg);
        ui_->showMessageBox("Medial Axis Generation - Error", errorMsg);
        return false;
    } catch (...) {
        std::string errorMsg = "Unknown error during medial axis generation";
        logger_->logError(errorMsg);
        ui_->showMessageBox("Medial Axis Generation - Error", errorMsg);
        return false;
    }
}

void PluginManager::addConstructionGeometryVisualization(
    Adapters::ISketch* sketch, const Geometry::MedialAxisResults& results,
    const Adapters::MedialAxisParameters& params,
    const Adapters::IWorkspace::TransformParams& transform,
    const std::vector<Geometry::Point2D>& polygon) {
    if (!sketch || !results.success) {
        return;
    }

    try {
        logger_->logInfo("Adding construction geometry visualization");
        
        // NOTE: Not applying any coordinate transformations
        // Fusion handles the transformation when creating sketch entities on the correct plane

        // Get properly sampled medial axis paths at user-specified sampling distance
        auto sampledPaths = medialProcessor_->getSampledPaths(results, params.samplingDistance);
        logger_->logInfo("Got " + std::to_string(sampledPaths.size()) + " sampled medial axis paths");
        
        // Log total points to check for excessive data
        size_t totalSampledPoints = 0;
        for (const auto& path : sampledPaths) {
            totalSampledPoints += path.points.size();
        }
        logger_->logInfo("Total sampled points: " + std::to_string(totalSampledPoints));

        // Enhanced UI Phase 5.3: Add medial axis lines using sampled paths
        if (params.showMedialLines && !sampledPaths.empty()) {
            logger_->logInfo("Drawing " + std::to_string(sampledPaths.size()) +
                             " sampled medial axis paths");

            size_t totalLinesDrawn = 0;
            const size_t MAX_CONSTRUCTION_LINES = 1000;  // Safety limit
            
            for (size_t pathIdx = 0; pathIdx < sampledPaths.size(); ++pathIdx) {
                const auto& path = sampledPaths[pathIdx];

                // Draw lines connecting points in the sampled path
                for (size_t i = 0; i < path.points.size() - 1; ++i) {
                    if (totalLinesDrawn >= MAX_CONSTRUCTION_LINES) {
                        logger_->logWarning("Reached maximum construction lines limit (" + 
                                          std::to_string(MAX_CONSTRUCTION_LINES) + ")");
                        break;
                    }
                    const auto& p1 = path.points[i].position;
                    const auto& p2 = path.points[i + 1].position;

                    // Sampled paths are already in world coordinates (mm)
                    double x1_world_mm = p1.x;
                    double y1_world_mm = p1.y;
                    double x2_world_mm = p2.x;
                    double y2_world_mm = p2.y;
                    
                    // NOTE: Temporarily removing transformation to test
                    // The coordinates from extractProfileVertices might already be in the correct space
                    
                    // Debug logging for first few lines
                    if (totalLinesDrawn < 5) {
                        logger_->logDebug("Construction line " + std::to_string(totalLinesDrawn) + 
                                        ": (" + std::to_string(x1_world_mm) + ", " + std::to_string(y1_world_mm) + 
                                        ") to (" + std::to_string(x2_world_mm) + ", " + std::to_string(y2_world_mm) + ") mm");
                    }

                    bool success =
                        sketch->addConstructionLine(x1_world_mm, y1_world_mm, x2_world_mm, y2_world_mm);
                    if (!success) {
                        logger_->logWarning("Failed to add construction line for path " +
                                            std::to_string(pathIdx) + ", segment " +
                                            std::to_string(i));
                    }
                    totalLinesDrawn++;
                }
                if (totalLinesDrawn >= MAX_CONSTRUCTION_LINES) break;
            }
            logger_->logInfo("Drew " + std::to_string(totalLinesDrawn) + " construction lines");
        }

        // Enhanced UI Phase 5.3: Add clearance circles at actual medial axis vertices only
        if (params.showClearanceCircles && results.success && !results.chains.empty()) {
            logger_->logInfo("Drawing clearance circles at actual medial axis vertices");

            size_t totalCirclesDrawn = 0;
            const size_t MAX_CONSTRUCTION_CIRCLES = 500;  // Safety limit
            
            // Draw clearance circles only at actual medial axis vertices from OpenVoronoi
            for (size_t chainIdx = 0; chainIdx < results.chains.size(); ++chainIdx) {
                const auto& chain = results.chains[chainIdx];
                const auto& clearances = results.clearanceRadii[chainIdx];
                
                if (chain.size() != clearances.size()) {
                    logger_->logWarning("Chain " + std::to_string(chainIdx) + 
                                      " has mismatched sizes: " + std::to_string(chain.size()) +
                                      " points vs " + std::to_string(clearances.size()) + " clearances");
                    continue;
                }
                
                logger_->logInfo("Processing chain " + std::to_string(chainIdx) + " with " + 
                               std::to_string(chain.size()) + " vertices");

                // Draw clearance circles for ALL vertices exactly as OpenVoronoi generated them
                // This confirms every circle shown is a genuine OpenVoronoi medial axis vertex
                logger_->logInfo("Drawing ALL " + std::to_string(chain.size()) + 
                               " OpenVoronoi medial axis vertices as clearance circles");

                for (size_t i = 0; i < chain.size(); ++i) {
                    if (totalCirclesDrawn >= MAX_CONSTRUCTION_CIRCLES) {
                        logger_->logWarning("Reached maximum construction circles limit (" + 
                                          std::to_string(MAX_CONSTRUCTION_CIRCLES) + ")");
                        break;
                    }
                    
                    // Chain points are in world coordinates (cm), convert to mm
                    double x_world_mm = chain[i].x * 10.0;
                    double y_world_mm = chain[i].y * 10.0;
                    double radius_world_mm = clearances[i] * 10.0;
                    
                    // Log every circle to verify they're all from OpenVoronoi
                    logger_->logDebug("OpenVoronoi circle " + std::to_string(totalCirclesDrawn) + 
                                    " (chain " + std::to_string(chainIdx) + ", vertex " + std::to_string(i) + ")" +
                                    ": (" + std::to_string(x_world_mm) + ", " + std::to_string(y_world_mm) + 
                                    ") radius " + std::to_string(radius_world_mm) + " mm");

                    // Draw clearance circle (even for very small radii to show boundary points)
                    bool circleSuccess = true;
                    if (radius_world_mm >= 0.01) {  // Only draw circle if radius is visible
                        circleSuccess = sketch->addConstructionCircle(x_world_mm, y_world_mm, radius_world_mm);
                    }
                    
                    // Optionally add a cross at the center to mark the medial axis point
                    bool crossSuccess1 = true;
                    bool crossSuccess2 = true;
                    
                    if (params.crossSize > 0.0) {
                        crossSuccess1 = sketch->addConstructionLine(
                            x_world_mm - params.crossSize, y_world_mm, 
                            x_world_mm + params.crossSize, y_world_mm);
                        crossSuccess2 = sketch->addConstructionLine(
                            x_world_mm, y_world_mm - params.crossSize, 
                            x_world_mm, y_world_mm + params.crossSize);
                    }

                    if (!circleSuccess || !crossSuccess1 || !crossSuccess2) {
                        logger_->logWarning("Failed to add construction geometry for chain " +
                                            std::to_string(chainIdx) + ", vertex " +
                                            std::to_string(i));
                    }
                    totalCirclesDrawn++;
                }
                if (totalCirclesDrawn >= MAX_CONSTRUCTION_CIRCLES) break;
            }
            logger_->logInfo("Drew " + std::to_string(totalCirclesDrawn) + 
                           " clearance circles at actual medial axis vertices");
        }

        // Enhanced UI Phase 5.3: Add polygonized shape outline
        if (params.showPolygonizedShape && !polygon.empty()) {
            logger_->logInfo("Drawing polygonized shape outline with " + 
                             std::to_string(polygon.size()) + " vertices");
            
            // Draw construction lines connecting the polygon vertices
            for (size_t i = 0; i < polygon.size(); ++i) {
                const auto& p1 = polygon[i];
                const auto& p2 = polygon[(i + 1) % polygon.size()];  // Wrap around to close polygon
                
                // Polygon vertices are in world coordinates (cm) from extractProfileGeometry
                // Convert from cm to mm (FusionSketch methods expect mm)
                double x1_world_mm = Utils::fusionLengthToMm(p1.x);
                double y1_world_mm = Utils::fusionLengthToMm(p1.y);
                double x2_world_mm = Utils::fusionLengthToMm(p2.x);
                double y2_world_mm = Utils::fusionLengthToMm(p2.y);
                
                // Add construction line directly in world coordinates
                bool success = sketch->addConstructionLine(x1_world_mm, y1_world_mm, x2_world_mm, y2_world_mm);
                if (!success) {
                    logger_->logWarning("Failed to add polygon edge " + std::to_string(i));
                }
            }
            
            logger_->logInfo("Polygonized shape outline completed");
        }

        logger_->logInfo("Construction geometry visualization completed");

    } catch (const std::exception& e) {
        logger_->logError("Failed to add construction geometry: " + std::string(e.what()));
    } catch (...) {
        logger_->logError("Unknown error adding construction geometry");
    }
}

bool PluginManager::extractProfileGeometry(
    const Adapters::SketchSelection& selection,
    std::vector<std::vector<Geometry::Point2D>>& profilePolygons,
    std::vector<Adapters::IWorkspace::TransformParams>& profileTransforms) {
    logger_->logInfo("========================================");
    logger_->logInfo("extractProfileGeometry() called!");
    logger_->logInfo("Enhanced UI Phase 5.2 - Profile geometry extraction");
    logger_->logInfo("========================================");

    if (!initialized_ || !workspace_) {
        logger_->logError(
            "CRITICAL: extractProfileGeometry() - PluginManager not properly initialized");
        logger_->logError("initialized_: " + std::string(initialized_ ? "true" : "false"));
        logger_->logError("workspace_: " + std::string(workspace_ ? "valid" : "null"));
        return false;
    }

    if (!selection.isValid || selection.selectedEntityIds.empty()) {
        logger_->logError("extractProfileGeometry() - Invalid selection");
        logger_->logError("selection.isValid: " +
                          std::string(selection.isValid ? "true" : "false"));
        logger_->logError("selection.selectedEntityIds.size(): " +
                          std::to_string(selection.selectedEntityIds.size()));
        return false;
    }

    profilePolygons.clear();
    profilePolygons.reserve(selection.selectedEntityIds.size());
    profileTransforms.clear();
    profileTransforms.reserve(selection.selectedEntityIds.size());

    try {
        logger_->logInfo("Extracting geometry from " +
                         std::to_string(selection.selectedEntityIds.size()) + " selected profiles");

        for (const auto& entityId : selection.selectedEntityIds) {
            std::vector<std::pair<double, double>> rawVertices;
            Adapters::IWorkspace::TransformParams transform;

            // Extract vertices from the profile using workspace interface
            logger_->logInfo("About to call workspace_->extractProfileVertices() for entity: " +
                             entityId);
            bool extractionSuccess =
                workspace_->extractProfileVertices(entityId, rawVertices, transform);
            logger_->logInfo("workspace_->extractProfileVertices() returned: " +
                             std::string(extractionSuccess ? "true" : "false"));
            logger_->logInfo("Raw vertices count: " + std::to_string(rawVertices.size()));

            if (!extractionSuccess || rawVertices.empty()) {
                logger_->logWarning("Failed to extract vertices from entity: " + entityId);
                logger_->logWarning("extractionSuccess: " +
                                    std::string(extractionSuccess ? "true" : "false"));
                logger_->logWarning("rawVertices.size(): " + std::to_string(rawVertices.size()));
                continue;  // Skip this profile but continue with others
            }

            // Convert raw vertices to Point2D vector
            std::vector<Geometry::Point2D> polygon;
            polygon.reserve(rawVertices.size());
            
            // Log first few vertices for debugging
            logger_->logInfo("Extracted profile " + std::to_string(profilePolygons.size()) + 
                           " from entity: " + entityId);
            for (size_t i = 0; i < std::min(size_t(5), rawVertices.size()); ++i) {
                logger_->logInfo("  Vertex " + std::to_string(i) + ": (" + 
                               std::to_string(rawVertices[i].first) + ", " + 
                               std::to_string(rawVertices[i].second) + ") cm");
            }
            
            // Calculate and log bounds
            if (!rawVertices.empty()) {
                double minX = rawVertices[0].first, maxX = rawVertices[0].first;
                double minY = rawVertices[0].second, maxY = rawVertices[0].second;
                for (const auto& v : rawVertices) {
                    minX = std::min(minX, v.first);
                    maxX = std::max(maxX, v.first);
                    minY = std::min(minY, v.second);
                    maxY = std::max(maxY, v.second);
                }
                logger_->logInfo("  Profile bounds: (" + std::to_string(minX) + ", " + std::to_string(minY) + 
                               ") to (" + std::to_string(maxX) + ", " + std::to_string(maxY) + ") cm");
                logger_->logInfo("  Profile center: (" + std::to_string((minX + maxX) / 2.0) + ", " + 
                               std::to_string((minY + maxY) / 2.0) + ") cm");
            }
            
            std::transform(rawVertices.begin(), rawVertices.end(), std::back_inserter(polygon),
                [](const auto& vertex) {
                    return Geometry::Point2D(vertex.first, vertex.second);
                });

            // Validate polygon has minimum vertices for processing
            if (polygon.size() < 3) {
                logger_->logWarning("Profile has insufficient vertices (" +
                                    std::to_string(polygon.size()) + ") for entity: " + entityId);
                continue;
            }

            // Follow Fusion's convention: polygons are implicitly closed
            // Do NOT add duplicate closing vertex - this causes validation issues
            logger_->logInfo("Polygon has " + std::to_string(polygon.size()) +
                             " vertices (Fusion convention - implicitly closed)");

            size_t vertexCount = polygon.size();  // Store size before move
            profilePolygons.push_back(std::move(polygon));
            profileTransforms.push_back(transform);  // Store the transformation parameters
            logger_->logInfo("Successfully extracted " + std::to_string(vertexCount) +
                             " vertices from entity: " + entityId);
        }

        if (profilePolygons.empty()) {
            logger_->logError("No valid profile geometries extracted from selection");
            return false;
        }

        logger_->logInfo("Profile geometry extraction completed: " +
                         std::to_string(profilePolygons.size()) + " profiles ready for processing");
        return true;

    } catch (const std::exception& e) {
        logger_->logError("Exception during profile geometry extraction: " + std::string(e.what()));
        return false;
    } catch (...) {
        logger_->logError("Unknown exception during profile geometry extraction");
        return false;
    }
}

std::string PluginManager::formatMedialAxisResults(const Geometry::MedialAxisResults& results) {
    std::string formatted = "Chains: " + std::to_string(results.numChains) +
                            ", Points: " + std::to_string(results.totalPoints) +
                            ", Length: " + std::to_string(static_cast<int>(results.totalLength)) +
                            "mm";

    if (results.totalPoints > 0) {
        formatted += ", Clearance: " + std::to_string(results.minClearance) + "-" +
                     std::to_string(results.maxClearance) + "mm";
    }

    return formatted;
}

bool PluginManager::generateVCarveToolpaths(const std::vector<Geometry::MedialAxisResults>& medialResults,
                                           const Adapters::MedialAxisParameters& params,
                                           Adapters::ISketch* sketch,
                                           const std::vector<Adapters::IWorkspace::TransformParams>& transforms) {
    if (!sketch || medialResults.empty()) {
        logger_->logError("Invalid parameters for V-carve generation");
        return false;
    }
    
    if (transforms.size() != medialResults.size()) {
        logger_->logError("Mismatch between medial results count (" + std::to_string(medialResults.size()) + 
                         ") and transforms count (" + std::to_string(transforms.size()) + ")");
        return false;
    }

    try {
        logger_->logInfo("Starting V-carve toolpath generation for " + 
                         std::to_string(medialResults.size()) + " medial axis results");
        logger_->logInfo("V-carve parameters: projectToSurface=" + 
                         std::string(params.projectToSurface ? "true" : "false") +
                         ", targetSurfaceId=" + params.targetSurfaceId);
        
        // NOTE: Not applying any coordinate transformations
        // Fusion handles the transformation when creating sketch entities on the correct plane

        // Create V-carve calculator
        Geometry::VCarveCalculator calculator;
        
        int totalVCarvePaths = 0;
        int totalVCarvePoints = 0;
        double totalVCarveLength = 0.0;

        // Process each medial axis result independently
        for (size_t i = 0; i < medialResults.size(); ++i) {
            const auto& medialResult = medialResults[i];
            const auto& transform = transforms[i];  // Get corresponding transform for this profile
            
            if (!medialResult.success || medialResult.chains.empty()) {
                logger_->logWarning("Skipping invalid medial axis result " + std::to_string(i + 1));
                continue;
            }

            logger_->logInfo("Generating V-carve paths for medial result " + std::to_string(i + 1) + 
                           " with " + std::to_string(medialResult.chains.size()) + " chains");

            // Get sketch plane Z in mm (transform stores it in cm)
            double sketchPlaneZ_mm = transform.sketchPlaneZ * 10.0;

            Geometry::VCarveResults vcarveResults;

            // Check if surface projection is needed
            if (params.projectToSurface && !params.targetSurfaceId.empty() && workspace_) {
                logger_->logInfo("Using surface projection for V-carve paths");
                
                // Create surface query function that calls workspace
                auto surfaceQuery = [this, &params](double x_mm, double y_mm) -> double {
                    // Convert mm to cm for Fusion API
                    double x_cm = x_mm / 10.0;
                    double y_cm = y_mm / 10.0;
                    double z_cm = workspace_->getSurfaceZAtXY(params.targetSurfaceId, x_cm, y_cm);
                    // Convert result back to mm
                    return z_cm * 10.0;
                };
                
                // Generate V-carve paths directly from raw medial axis results
                // This preserves only the original OpenVoronoi vertices (same as non-surface path)
                vcarveResults = calculator.generateVCarvePaths(medialResult, params);
                
                // Apply surface projection to the V-carve points
                for (auto& vcarvePath : vcarveResults.paths) {
                    for (auto& vcarvePoint : vcarvePath.points) {
                        // Query surface Z at this XY position
                        double surfaceZ_mm = surfaceQuery(vcarvePoint.position.x, vcarvePoint.position.y);
                        if (!std::isnan(surfaceZ_mm)) {
                            // Store the original depth (how deep below sketch plane)
                            double originalDepth = vcarvePoint.depth;
                            
                            // For surface projection, we need to store how far below the surface to carve
                            // NOT the absolute Z position
                            
                            // Store the original carve depth with a marker to indicate surface projection
                            // We use a large negative offset to distinguish from regular depths
                            const double SURFACE_PROJECTION_MARKER = -1000000.0;
                            vcarvePoint.depth = SURFACE_PROJECTION_MARKER - originalDepth;
                            
                            // Also store the surface Z for later use
                            // We'll use the clearanceRadius field temporarily since we're already calculating it
                            vcarvePoint.clearanceRadius = surfaceZ_mm;
                            
                            // Debug logging
                            logger_->logInfo("Surface projection at (" + std::to_string(vcarvePoint.position.x) + 
                                           ", " + std::to_string(vcarvePoint.position.y) + "): " +
                                           "surfaceZ=" + std::to_string(surfaceZ_mm) + "mm, " +
                                           "sketchZ=" + std::to_string(sketchPlaneZ_mm) + "mm, " +
                                           "originalDepth=" + std::to_string(originalDepth) + "mm, " +
                                           "targetZ=" + std::to_string(surfaceZ_mm - originalDepth) + "mm");
                        }
                    }
                }
            } else {
                // Generate V-carve paths without surface projection
                logger_->logInfo("Generating V-carve paths without surface projection");
                
                // Generate V-carve paths directly from raw medial axis results
                // This preserves only the original OpenVoronoi vertices (clearance circle locations)
                vcarveResults = calculator.generateVCarvePaths(medialResult, params);
            }

            if (!vcarveResults.success) {
                logger_->logError("Failed to generate V-carve paths for result " + std::to_string(i + 1) + 
                                ": " + vcarveResults.errorMessage);
                continue;
            }

            logger_->logInfo("Generated " + std::to_string(vcarveResults.totalPaths) + 
                           " V-carve paths with " + std::to_string(vcarveResults.totalPoints) + " points");

            // Add V-carve paths to sketch as 3D splines
            for (const auto& vcarvePath : vcarveResults.paths) {
                if (!vcarvePath.isValid()) {
                    continue;
                }

                // Convert VCarvePoints to Point3D for spline creation
                std::vector<Geometry::Point3D> splinePoints;
                splinePoints.reserve(vcarvePath.points.size());

                for (const auto& vcarvePoint : vcarvePath.points) {
                    // V-carve points are already in world coordinates (mm)
                    double x_world_mm = vcarvePoint.position.x;
                    double y_world_mm = vcarvePoint.position.y;
                    
                    // Debug logging for first few points
                    if (splinePoints.size() < 3) {
                        logger_->logDebug("V-carve point: (" + std::to_string(x_world_mm) + ", " + 
                                        std::to_string(y_world_mm) + 
                                        ") mm, depth " + std::to_string(vcarvePoint.depth) + " mm" +
                                        (vcarvePoint.depth < 0 ? " (absolute Z)" : " (relative)"));
                    }
                    
                    // Calculate Z coordinate
                    // IMPORTANT: Fusion interprets 3D sketch Z coordinates as RELATIVE to the sketch plane
                    double z_sketch_relative_mm;
                    
                    const double SURFACE_PROJECTION_MARKER = -1000000.0;
                    if (vcarvePoint.depth < SURFACE_PROJECTION_MARKER + 1000.0) {
                        // This is a surface projection point
                        // Extract the carve depth from the encoded value
                        double carveDepth = -(vcarvePoint.depth - SURFACE_PROJECTION_MARKER);
                        double surfaceZ_mm = vcarvePoint.clearanceRadius; // Temporarily stored here
                        
                        // Calculate the target Z position (surfaceZ - carveDepth)
                        double targetZ_mm = surfaceZ_mm - carveDepth;
                        
                        // Convert to sketch-relative coordinates
                        z_sketch_relative_mm = targetZ_mm - sketchPlaneZ_mm;
                        
                        logger_->logDebug("Surface projection: carveDepth=" + std::to_string(carveDepth) + 
                                        "mm, surfaceZ=" + std::to_string(surfaceZ_mm) + 
                                        "mm, targetZ=" + std::to_string(targetZ_mm) + 
                                        "mm, sketchZ=" + std::to_string(sketchPlaneZ_mm) + 
                                        "mm, sketch-relative=" + std::to_string(z_sketch_relative_mm) + "mm");
                    } else {
                        // Regular depth, carve below the sketch plane
                        z_sketch_relative_mm = -vcarvePoint.depth;
                    }
                    
                    // Debug logging for final Z calculation
                    if (splinePoints.size() < 3) {
                        double absoluteZ = z_sketch_relative_mm + sketchPlaneZ_mm;
                        logger_->logDebug("  Z calculation: sketch-relative=" + std::to_string(z_sketch_relative_mm) + 
                                        "mm, absolute=" + std::to_string(absoluteZ) + "mm" +
                                        " (sketch at Z=" + std::to_string(sketchPlaneZ_mm) + "mm)");
                    }
                    
                    // Create 3D point with sketch-relative coordinates
                    // XY are in world coordinates, Z is relative to sketch plane
                    Geometry::Point3D point3D(x_world_mm, y_world_mm, z_sketch_relative_mm);
                    splinePoints.push_back(point3D);
                }

                // Add 3D spline to sketch
                if (splinePoints.size() >= 2) {
                    // Log first and last points for debugging
                    const auto& firstPt = splinePoints.front();
                    const auto& lastPt = splinePoints.back();
                    logger_->logInfo("V-carve spline: first point (" + std::to_string(firstPt.x) + ", " + 
                                   std::to_string(firstPt.y) + ", " + std::to_string(firstPt.z) + 
                                   "), last point (" + std::to_string(lastPt.x) + ", " + 
                                   std::to_string(lastPt.y) + ", " + std::to_string(lastPt.z) + ")");
                    
                    bool success = sketch->addSpline3D(splinePoints);
                    if (!success) {
                        logger_->logWarning("Failed to add V-carve spline with " + 
                                          std::to_string(splinePoints.size()) + " points");
                    }
                } else {
                    logger_->logWarning("Skipping V-carve path with insufficient points: " + 
                                      std::to_string(splinePoints.size()));
                }
            }

            // Update totals
            totalVCarvePaths += vcarveResults.totalPaths;
            totalVCarvePoints += vcarveResults.totalPoints;
            totalVCarveLength += vcarveResults.totalLength;
        }

        if (totalVCarvePaths > 0) {
            logger_->logInfo("V-carve generation completed: " + std::to_string(totalVCarvePaths) + 
                           " paths, " + std::to_string(totalVCarvePoints) + " points, " + 
                           std::to_string(static_cast<int>(totalVCarveLength)) + "mm total length");
            return true;
        } else {
            logger_->logWarning("No V-carve paths generated");
            return false;
        }

    } catch (const std::exception& e) {
        logger_->logError("Exception during V-carve generation: " + std::string(e.what()));
        return false;
    } catch (...) {
        logger_->logError("Unknown exception during V-carve generation");
        return false;
    }
}

}  // namespace Core
}  // namespace ChipCarving