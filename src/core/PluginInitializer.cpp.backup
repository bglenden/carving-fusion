#include "PluginInitializer.h"

#include "../adapters/FusionAPIAdapter.h"
#include "../commands/PluginCommands.h"
#include "../core/PluginManager.h"
#include "../version.h"
#include "../../include/utils/TempFileManager.h"
#include <cstdio>
// TODO: Fix HelloWorldCommand API issues
// #include "../../include/commands/HelloWorldCommand.h"
#include <Core/Application/Document.h>
#include <Core/CoreAll.h>
#include <Core/UserInterface/CommandControl.h>
#include <Core/UserInterface/Toolbar.h>
#include <Core/UserInterface/ToolbarPanel.h>
#include <Core/UserInterface/ToolbarPanels.h>
#include <Core/UserInterface/ToolbarTab.h>
#include <Core/UserInterface/ToolbarTabs.h>
#include <Core/UserInterface/Toolbars.h>
#include <Core/UserInterface/Workspace.h>
#include <Fusion/FusionAll.h>

#include <chrono>
#include <cstdlib>
#include <iomanip>
#include <sstream>

using namespace adsk::core;
using namespace adsk::fusion;

namespace ChipCarving {

// Global variables
static Ptr<Application> app;
static Ptr<UserInterface> ui;
static std::unique_ptr<Core::PluginManager> pluginManager;
static Ptr<ToolbarPanel> panel;
static std::vector<Ptr<CommandDefinition>> commandDefinitions;
static std::vector<Ptr<CommandControl>> commandControls;
static std::shared_ptr<Commands::ImportDesignCommandHandler> importHandler;
static std::shared_ptr<Commands::GeneratePathsCommandHandler> generateHandler;

PluginMode PluginInitializer::GetModeFromEnv() {
    const char* mode = std::getenv("CHIP_CARVING_PLUGIN_MODE");
    if (!mode) {
        return PluginMode::STANDARD;
    }

    std::string modeStr(mode);
    if (modeStr == "DEBUG") {
        return PluginMode::DEBUG_MODE;
    } else if (modeStr == "COMMANDS_ONLY") {
        return PluginMode::COMMANDS_ONLY;
    } else if (modeStr == "UI_SIMPLE") {
        return PluginMode::UI_SIMPLE;
    } else if (modeStr == "REFACTORED") {
        return PluginMode::REFACTORED;
    }

    return PluginMode::STANDARD;
}

void PluginInitializer::LogMessage(const std::string& message) {
    try {
        if (!ui)
            return;

        auto now = std::chrono::system_clock::now();
        auto time_t = std::chrono::system_clock::to_time_t(now);

        std::stringstream ss;
        ss << "[" << std::put_time(std::localtime(&time_t), "%Y-%m-%d %H:%M:%S") << "] ";
        ss << "ChipCarvingCpp: " << message;

        Ptr<Palettes> palettes = ui->palettes();
        if (palettes) {
            Ptr<TextCommandPalette> textPalette = palettes->itemById("TextCommands");
            if (textPalette) {
                textPalette->writeText(ss.str());
            }
        }
    } catch (...) {
        // Ignore logging errors
    }
}

bool PluginInitializer::CreateToolbarPanel() {
    try {
        LogMessage("CreateToolbarPanel: Starting toolbar panel creation");

        if (!ui) {
            LogMessage("ERROR: UI is null");
            return false;
        }

        LogMessage("CreateToolbarPanel: Getting workspaces");
        Ptr<Workspaces> workspaces = ui->workspaces();
        if (!workspaces) {
            LogMessage("ERROR: Could not get workspaces");
            return false;
        }

        LogMessage("CreateToolbarPanel: Getting Design workspace");
        Ptr<Workspace> designWorkspace = workspaces->itemById("FusionSolidEnvironment");
        if (!designWorkspace) {
            LogMessage("ERROR: Could not find Design workspace");

            // List available workspaces
            LogMessage("Available workspaces:");
            for (size_t i = 0; i < workspaces->count(); i++) {
                Ptr<Workspace> ws = workspaces->item(i);
                if (ws) {
                    LogMessage("  - " + ws->id() + " : " + ws->name());
                }
            }
            return false;
        }

        LogMessage("CreateToolbarPanel: Found workspace: " + designWorkspace->name());
        LogMessage("CreateToolbarPanel: Workspace ID: " + designWorkspace->id());
        LogMessage("CreateToolbarPanel: Is workspace active: " +
                   std::string(designWorkspace->isActive() ? "yes" : "no"));

        // Alternative approach - try getting all toolbars from UI
        LogMessage("CreateToolbarPanel: Trying alternative approach through UI");

        // First, let's see what toolbars are available
        try {
            Ptr<Toolbars> toolbars = ui->toolbars();
            if (toolbars) {
                LogMessage("CreateToolbarPanel: Found " + std::to_string(toolbars->count()) +
                           " toolbars");
                for (size_t i = 0; i < toolbars->count() && i < 5; i++) {
                    Ptr<Toolbar> tb = toolbars->item(i);
                    if (tb) {
                        LogMessage("  Toolbar " + std::to_string(i) + ": " + tb->id());
                    }
                }
            }
        } catch (...) {
            LogMessage("ERROR: Could not enumerate toolbars");
        }

        // Check for active document first
        LogMessage("CreateToolbarPanel: Checking for active document");
        Ptr<Document> activeDoc = app->activeDocument();
        if (!activeDoc) {
            LogMessage("ERROR: No active document - this may cause toolbarPanels to return null");
            LogMessage("CreateToolbarPanel: Trying to proceed anyway...");
        } else {
            LogMessage("CreateToolbarPanel: Active document found: " + activeDoc->name());
        }

        // Try the original approach but with better error handling
        LogMessage("CreateToolbarPanel: Getting toolbar panels from workspace");
        Ptr<ToolbarPanels> panels;
        try {
            panels = designWorkspace->toolbarPanels();
            if (!panels) {
                LogMessage("ERROR: toolbarPanels() returned null");

                // Use getLastError() for more details
                LogMessage("CreateToolbarPanel: Checking last error...");
                int errorCode = app->getLastError();
                if (errorCode != 0) {
                    LogMessage("Last Error Code: " + std::to_string(errorCode));
                }

                // Try using an existing panel instead of creating a new one
                LogMessage("CreateToolbarPanel: Trying alternative: find existing ADD-INS panel");
                // Look for a standard panel we can add commands to
                Ptr<ToolbarPanel> addInsPanel = nullptr;

                // Try to get the workspace's toolbar panels through a different method
                LogMessage("CreateToolbarPanel: Attempting workspace activation");
                if (designWorkspace->activate()) {
                    LogMessage("CreateToolbarPanel: Workspace activated, retrying toolbarPanels()");
                    panels = designWorkspace->toolbarPanels();
                    if (panels) {
                        LogMessage("CreateToolbarPanel: Success! Got panels after activation");
                        // Try to find ADD-INS panel
                        addInsPanel = panels->itemById("SolidScriptsAddinsPanel");
                        if (addInsPanel) {
                            LogMessage("CreateToolbarPanel: Found ADD-INS panel, will use it");
                            panel = addInsPanel;
                        }
                    }
                }

                if (!panel) {
                    LogMessage("ERROR: All panel creation methods failed");
                    return false;
                }
            } else {
                LogMessage("CreateToolbarPanel: Got toolbar panels successfully");
            }
        } catch (const std::exception& e) {
            LogMessage("ERROR: Exception calling toolbarPanels(): " + std::string(e.what()));
            return false;
        } catch (...) {
            LogMessage("ERROR: Unknown exception calling toolbarPanels()");
            return false;
        }

        // Create or get the Chip Carving panel (if not already created through tab)
        if (!panel) {
            std::string panelId = "ChipCarvingPanelCpp";
            LogMessage("CreateToolbarPanel: Looking for panel: " + panelId);
            panel = panels->itemById(panelId);

            if (!panel) {
                LogMessage("CreateToolbarPanel: Creating new panel: " + panelId);
                panel = panels->add(panelId, "Chip Carving C++", "SelectPanel", false);
                if (panel) {
                    LogMessage("Created new Chip Carving C++ panel");
                } else {
                    LogMessage("ERROR: Failed to create panel");
                    return false;
                }
            } else {
                LogMessage("Using existing Chip Carving C++ panel");
            }
        }

        // Create commands
        LogMessage("CreateToolbarPanel: Creating commands");
        CreateImportDesignCommand();
        CreateGeneratePathsCommand();

        LogMessage("CreateToolbarPanel: Completed successfully");
        return true;
    } catch (const std::exception& e) {
        LogMessage("ERROR: CreateToolbarPanel exception: " + std::string(e.what()));
        return false;
    } catch (...) {
        LogMessage("ERROR: CreateToolbarPanel unknown exception");
        return false;
    }
}


bool PluginInitializer::InitializePlugin(const char* context, PluginMode mode) {
    // Debug: Write to file to track initialization
    chip_carving::TempFileManager::ensureTempDirectoryExists();
    std::string debugLogPath = chip_carving::TempFileManager::getLogFilePath("fusion_plugin_start.log");
    FILE* debugFile = fopen(debugLogPath.c_str(), "a");
    if (debugFile) {
        fprintf(debugFile, "InitializePlugin called\n");
        fclose(debugFile);
    }
    
    try {
        app = Application::get();
        if (!app) {
            if (debugFile) {
                debugFile = fopen(debugLogPath.c_str(), "a");
                fprintf(debugFile, "Failed to get Application\n");
                fclose(debugFile);
            }
            return false;
        }

        ui = app->userInterface();
        if (!ui) {
            if (debugFile) {
                debugFile = fopen(debugLogPath.c_str(), "a");
                fprintf(debugFile, "Failed to get UserInterface\n");
                fclose(debugFile);
            }
            return false;
        }

        LogMessage("Starting Chip Carving Paths C++ Add-in v" + std::string(ADDIN_VERSION_STRING));

        // Create plugin manager based on mode
        switch (mode) {
            case PluginMode::DEBUG_MODE:
                // Add debug-specific initialization
                break;
            case PluginMode::COMMANDS_ONLY:
                // Minimal command setup
                break;
            case PluginMode::UI_SIMPLE:
                // Simple UI setup
                break;
            case PluginMode::REFACTORED:
                // Use refactored plugin manager
                break;
            case PluginMode::STANDARD:
            default:
                break;
        }

        // Initialize plugin manager with factory
        std::string logPath = "/tmp/chip_carving_cpp.log";
        auto factory = std::make_unique<Adapters::FusionAPIFactory>(app, ui, logPath);
        pluginManager = std::make_unique<Core::PluginManager>(std::move(factory));
        if (!pluginManager->initialize()) {
            LogMessage("ERROR: Failed to initialize plugin manager");
            return false;
        }

        // Try toolbar creation with extensive logging

        if (!CreateToolbarPanel()) {
            LogMessage("WARNING: Failed to create toolbar panel");
            // Continue anyway - plugin can still function
        }

        LogMessage("Chip Carving Paths C++ Add-in started successfully");
        return true;
    } catch (const std::exception& e) {
        if (ui) {
            ui->messageBox("Failed to start Chip Carving Paths add-in: " + std::string(e.what()),
                           "Chip Carving Paths Error");
        }
        return false;
    } catch (...) {
        if (ui) {
            ui->messageBox("Failed to start Chip Carving Paths add-in: Unknown error",
                           "Chip Carving Paths Error");
        }
        return false;
    }
}

bool PluginInitializer::ShutdownPlugin() {
    try {
        LogMessage("Stopping Chip Carving Paths C++ Add-in");

        // Clean up UI elements
        for (auto& control : commandControls) {
            if (control && control->isValid()) {
                control->deleteMe();
            }
        }
        commandControls.clear();

        for (auto& cmdDef : commandDefinitions) {
            if (cmdDef && cmdDef->isValid()) {
                cmdDef->deleteMe();
            }
        }
        commandDefinitions.clear();

        if (pluginManager) {
            pluginManager->shutdown();
            pluginManager.reset();
        }

        LogMessage("Chip Carving Paths C++ Add-in stopped");
        return true;
    } catch (...) {
        return false;
    }
}

void PluginInitializer::CreateImportDesignCommand() {
    try {
        std::string cmdId = "ChipCarvingImportDesignCpp";

        LogMessage("Creating Import Design command: " + cmdId);

        Ptr<CommandDefinitions> cmdDefs = ui->commandDefinitions();
        if (!cmdDefs) {
            LogMessage("ERROR: Could not get command definitions");
            return;
        }

        Ptr<CommandDefinition> cmdDef = cmdDefs->itemById(cmdId);

        if (!cmdDef) {
            std::string cmdName = "Import Design";
            std::string cmdTooltip = "Import chip carving design from JSON file";
            cmdDef = cmdDefs->addButtonDefinition(cmdId, cmdName, cmdTooltip, "./resources/import");
            if (cmdDef) {
                commandDefinitions.push_back(cmdDef);
                LogMessage("Import Design command definition created");
            } else {
                LogMessage("ERROR: Failed to create Import Design command definition");
                return;
            }
        }

        // Create and connect event handler
        if (!importHandler && pluginManager) {
            // Convert unique_ptr to shared_ptr for command handler
            std::shared_ptr<Core::PluginManager> sharedManager(pluginManager.get(),
                                                               [](Core::PluginManager*) {});
            importHandler = std::make_shared<Commands::ImportDesignCommandHandler>(sharedManager);
            cmdDef->commandCreated()->add(importHandler.get());
            LogMessage("Import Design command handler connected");
        }

        if (panel) {
            Ptr<ToolbarControls> controls = panel->controls();
            if (controls) {
                Ptr<CommandControl> cmdControl = controls->itemById(cmdId);
                if (!cmdControl) {
                    cmdControl = controls->addCommand(cmdDef);
                    if (cmdControl) {
                        commandControls.push_back(cmdControl);
                        LogMessage("Import Design command added to panel");
                    }
                }
            }
        }
    } catch (std::exception& e) {
        LogMessage("ERROR creating Import Design command: " + std::string(e.what()));
    }
}

void PluginInitializer::CreateGeneratePathsCommand() {
    try {
        std::string cmdId = "ChipCarvingGeneratePathsCpp";

        LogMessage("Creating Generate Paths command: " + cmdId);

        Ptr<CommandDefinitions> cmdDefs = ui->commandDefinitions();
        if (!cmdDefs) {
            LogMessage("ERROR: Could not get command definitions");
            return;
        }

        Ptr<CommandDefinition> cmdDef = cmdDefs->itemById(cmdId);

        if (!cmdDef) {
            std::string cmdName = "Generate Paths";
            std::string cmdTooltip = "Generate CNC toolpaths from imported design";
            cmdDef =
                cmdDefs->addButtonDefinition(cmdId, cmdName, cmdTooltip, "./resources/generate");
            if (cmdDef) {
                commandDefinitions.push_back(cmdDef);
                LogMessage("Generate Paths command definition created");
            } else {
                LogMessage("ERROR: Failed to create Generate Paths command definition");
                return;
            }
        }

        // Create and connect event handler
        if (!generateHandler && pluginManager) {
            // Convert unique_ptr to shared_ptr for command handler
            std::shared_ptr<Core::PluginManager> sharedManager(pluginManager.get(),
                                                               [](Core::PluginManager*) {});
            generateHandler =
                std::make_shared<Commands::GeneratePathsCommandHandler>(sharedManager);
            cmdDef->commandCreated()->add(generateHandler.get());
            LogMessage("Generate Paths command handler connected");
        }

        if (panel) {
            Ptr<ToolbarControls> controls = panel->controls();
            if (controls) {
                Ptr<CommandControl> cmdControl = controls->itemById(cmdId);
                if (!cmdControl) {
                    cmdControl = controls->addCommand(cmdDef);
                    if (cmdControl) {
                        commandControls.push_back(cmdControl);
                        LogMessage("Generate Paths command added to panel");
                    }
                }
            }
        }
    } catch (std::exception& e) {
        LogMessage("ERROR creating Generate Paths command: " + std::string(e.what()));
    }
}

}  // namespace ChipCarving